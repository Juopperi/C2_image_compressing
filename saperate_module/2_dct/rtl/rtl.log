module dct_1d_8x1 #(
    parameter DATA_WIDTH = 32
)(
    input  wire clk,
    input  wire reset_n,
    input  wire [DATA_WIDTH*8-1:0] data_in,
    input  wire [DATA_WIDTH*64-1:0] coeff_vector,  // 输入完整系数矩阵
    output wire [DATA_WIDTH*8-1:0] dct_out
);

    genvar i;
    generate
        for (i = 0; i < 8; i = i + 1) begin : DCT_ROW
            wire [DATA_WIDTH*8-1:0] coeff_i;
            assign coeff_i = coeff_vector[(7 - i)*DATA_WIDTH*8 +: DATA_WIDTH*8];  // 行翻转提取

            wire signed [DATA_WIDTH-1:0] dct_result_raw;
            wire signed [DATA_WIDTH-1:0] dct_result_fixed;

            dct_8muladd #(
                .DATA_WIDTH(DATA_WIDTH),
                .DATA_DEPTH(8)
            ) dct_unit (
                .clk(clk),
                .reset_n(reset_n),
                .data_in(data_in),
                .coeff(coeff_i),
                .data_out(dct_result_raw)
            );

            // 对第 1/3/5/7 项做补码取负，其余保持原样
            assign dct_result_fixed = (i % 2 == 1) ? -dct_result_raw : dct_result_raw;
            // assign dct_result_fixed = dct_result_raw;

            assign dct_out[i*DATA_WIDTH +: DATA_WIDTH] = dct_result_fixed;
        end
    endgenerate

endmodule
module dct_1d_8x8 #(
    parameter DATA_WIDTH = 32
)(
    input  wire clk,
    input  wire reset_n,
    input  wire [DATA_WIDTH*64-1:0] data_in,           // 64 个像素值 f(i,j)
    input  wire [DATA_WIDTH*64-1:0] coeff_vector,      // 64 个系数 c(i,j)
    output wire [DATA_WIDTH*64-1:0] dct_out            // 64 个 DCT 输出 F(i,j)
);

    genvar i;
    generate
        for (i = 0; i < 8; i = i + 1) begin : DCT_ROW
            wire [DATA_WIDTH*8-1:0] row_data;
            wire [DATA_WIDTH*8-1:0] row_dct;

            assign row_data  = data_in[i*DATA_WIDTH*8 +: DATA_WIDTH*8];

            
            dct_1d_8x1 #(
                .DATA_WIDTH(DATA_WIDTH)
            ) dct_unit_8x1 (
                .clk(clk),
                .reset_n(reset_n),
                .data_in(row_data),
                .coeff_vector(coeff_vector),  // 子模块内部将分解系数
                .dct_out(row_dct)
            );

            assign dct_out[i*DATA_WIDTH*8 +: DATA_WIDTH*8] = row_dct;
        end
    endgenerate

endmodule
module dct_2d_8x8 #(
    parameter DATA_WIDTH = 32,
    parameter DATA_DEPTH = 8
)(
    input  wire clk,
    input  wire reset_n,
    input  wire [DATA_WIDTH*DATA_DEPTH*DATA_DEPTH-1:0] data_in_matrix,     // 64个像素输入
    output wire [DATA_WIDTH*DATA_DEPTH*DATA_DEPTH-1:0] data_out_matrix     // 64个 DCT 输出
);

    localparam TOTAL_WIDTH = DATA_WIDTH * DATA_DEPTH;

    // --------- 包含定义的系数 ---------
    `include "dct_coeffs.vh"

    // --------- 行方向 DCT ---------
    wire [DATA_WIDTH*64-1:0] row_dct_flat;

    dct_1d_8x8 #(
        .DATA_WIDTH(DATA_WIDTH)
    ) row_dct_inst (
        .clk(clk),
        .reset_n(reset_n),
        .data_in(data_in_matrix),
        .coeff_vector(dct_coeffs),
        .dct_out(row_dct_flat)
    );

    // --------- 中间转置 (8x8) ---------
    wire [DATA_WIDTH*64-1:0] col_data_flat;

    genvar i, j;
    generate
        for (i = 0; i < 8; i = i + 1) begin : TRANS_ROW
            for (j = 0; j < 8; j = j + 1) begin : TRANS_COL
                assign col_data_flat[j*8*DATA_WIDTH + i*DATA_WIDTH +: DATA_WIDTH] =
                       row_dct_flat[i*8*DATA_WIDTH + j*DATA_WIDTH +: DATA_WIDTH];
            end
        end
    endgenerate

    // --------- 列方向 DCT ---------
    wire [DATA_WIDTH*64-1:0] final_dct_transposed;

    dct_1d_8x8 #(
        .DATA_WIDTH(DATA_WIDTH)
    ) col_dct_inst (
        .clk(clk),
        .reset_n(reset_n),
        .data_in(col_data_flat),
        .coeff_vector(dct_coeffs),
        .dct_out(final_dct_transposed)
    );

    // --------- 最终转置回原格式 (8x8) ---------
    genvar m, n;
    generate
        for (m = 0; m < 8; m = m + 1) begin : FINAL_ROW
            for (n = 0; n < 8; n = n + 1) begin : FINAL_COL
                assign data_out_matrix[m*8*DATA_WIDTH + n*DATA_WIDTH +: DATA_WIDTH] =
                       final_dct_transposed[n*8*DATA_WIDTH + m*DATA_WIDTH +: DATA_WIDTH];
            end
        end
    endgenerate

endmodule
module dct_8muladd #
(
    parameter DATA_WIDTH = 32,      // Q16.16 格式
    parameter DATA_DEPTH = 8
)
(
    input  wire clk,
    input  wire reset_n,
    input  wire [DATA_WIDTH*DATA_DEPTH-1:0] data_in,
    input  wire [DATA_WIDTH*DATA_DEPTH-1:0] coeff,
    output reg  [DATA_WIDTH-1:0] data_out
);

    // integer i;

    wire signed [DATA_WIDTH-1:0] data_array  [0:DATA_DEPTH-1];
    wire signed [DATA_WIDTH-1:0] coeff_array [0:DATA_DEPTH-1];
    wire signed [DATA_WIDTH-1:0] mult_out    [0:DATA_DEPTH-1];
    wire signed [DATA_WIDTH-1:0] add_chain   [0:DATA_DEPTH];

    assign add_chain[0] = '0;  // 初始化累加器

    // 拆分输入数据和系数
    genvar idx;
    generate
        for (idx = 0; idx < DATA_DEPTH; idx = idx + 1) begin : unpack_inputs
            assign data_array[idx]  = data_in [idx*DATA_WIDTH +: DATA_WIDTH];
            assign coeff_array[idx] = coeff    [idx*DATA_WIDTH +: DATA_WIDTH];
        end
    endgenerate

    // 实例化乘法器
    generate
        for (idx = 0; idx < DATA_DEPTH; idx = idx + 1) begin : mul_stage
            fixed_multiplier mul_inst (
                .a       (data_array[idx]),
                .b       (coeff_array[idx]),
                .mul_res (mult_out[idx])
            );
        end
    endgenerate

    // -------- 树状加法器结构 --------
    // 中间结果临时线网
    wire signed [DATA_WIDTH-1:0] sum_stage [0:DATA_DEPTH-2];  // 7 个中间节点
    genvar i;

    // Level 1: 4 pairwise additions
    generate
        for (i = 0; i < 4; i = i + 1) begin : add_level1
            fixed_adder add_inst (
                .a(mult_out[2*i]),
                .b(mult_out[2*i + 1]),
                .sum_out(sum_stage[i])
            );
        end
    endgenerate

    // Level 2: 2 additions
    generate
        for (i = 0; i < 2; i = i + 1) begin : add_level2
            fixed_adder add_inst (
                .a(sum_stage[2*i]),
                .b(sum_stage[2*i + 1]),
                .sum_out(sum_stage[4 + i])
            );
        end
    endgenerate

    // Level 3: final addition
    fixed_adder add_final (
        .a(sum_stage[4]),
        .b(sum_stage[5]),
        .sum_out(sum_stage[6])
    );


    // 输出最终值
    always @(posedge clk or negedge reset_n) begin
        if (!reset_n)
            data_out <= 0;
        else
            data_out <= sum_stage[6];
    end

endmodule
